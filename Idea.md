# idea

* 搜索的时候保证所有的`path[i] >= path[0]`就不需要去重排序
* 最短路优化剪枝


# to think

* 两种搜索的方法
    * zzl的搜索方法是不是不太好做并行化？？
    * 并且没有办法使用最短路优化
    * 但是看起来本来就快，不用最短路是否也快？
* normalize
    * node-id转连续id的时候需要排序
        * 需要吗？在zzl的搜索里也许不需要
    * 如何用hash表快速normalize
    * 自己实现的hash表会更快吗？
* 排序的时候基数排序能否并行
    * 是否能够用基数排序呢？
    * 会比归并排序效率更高吗？
* 对路径排序占了主要的时间
    * 可以将路径转为pair<int, double>
        * 第一个int是长度
        * 第二个double是路径转为2.8W进制后的数取log，好像不太对
        * 将2.8W映射到0~1的区间上，然后用十进制表示小数来排序 ？
        * 精度会不会不够？
* 最短路空间不够？
    * 用7个bitmap存
    * 判断是否是长度为k的边
    * 好像还是要很大的空间
    * 有没有更好的方法
* 自己hash函数的设计
    * 考虑完全随机和完全按照标号排列
    * hash = (short)((x >> 16) ^ x)
    * 操作更简单，在28W个随机数据的情况下，快了20倍