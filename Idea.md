# idea

* 搜索的时候保证所有的`path[i] >= path[0]`就不需要去重排序
* 最短路优化剪枝
* **注意**，id是32位无符号整数

# to think

* 两种搜索的方法
    * zzl的搜索方法是不是不太好做并行化？？
    * 并且没有办法使用最短路优化
    * 但是看起来本来就快，不用最短路是否也快？
* normalize
    * node-id转连续id的时候需要排序
        * 需要吗？在zzl的搜索里也许不需要
    * 如何用hash表快速normalize
    * 自己实现的hash表会更快吗？
* 排序的时候基数排序能否并行
    * 是否能够用基数排序呢？
    * 会比归并排序效率更高吗？
* 对路径排序占了主要的时间
    * 可以将路径转为pair<int, double>
        * 第一个int是长度
        * 第二个double是路径转为2.8W进制后的数取log，好像不太对
        * 将2.8W映射到0~1的区间上，然后用十进制表示小数来排序 ？
        * 精度会不会不够？
* 最短路空间不够？
    * 用7个bitmap存
    * 判断是否是长度为k的边
    * 好像还是要很大的空间
    * 有没有更好的方法
* 自己hash函数的设计
    * 考虑完全随机和完全按照标号排列
    * hash = (short)((x >> 16) ^ x)
    * 操作更简单，在28W个随机数据的情况下，快了20倍
* 最短路算法相当于矩阵乘法吗？
    * 有很成熟的方法可以并行做矩阵乘法

# u-search

* 读入
* 映射为0-node_num，不排序
* 构建正反拓扑序
    * 节点拓扑排序删除节点
* 对点进行排序并且重新映射
* 删除节点后重新建边
    * 对边拓扑排序删除无用边
* 重新建边，并且建成连续的边
    * 对边排序
* 搜索
* 输出答案

# 加速

* 为了快速获得答案，不用存第一个，因为都是链表，第一个已经确定了